# `wuf make`

- [Usage](#usage)
- [Simplest usage](#simplest-usage)
- [Usage of a template](#usage-of-a-template)
- [Usage of a plugin](#usage-of-a-plugin)
  - [Exporting a plugin](#exporting-a-plugin)
  - [Plugin API](#plugin-api)
    - [`data` parameter](#`data`-parameter)
    - [`api` parameter](#`api`-parameter)
- [Advanced example](#advanced-example)

`wuf make` command is used make (or generate) files. It takes JSON as input,
optionally modifies that input through a javascript function (a plugin) and
renders an EJS template.

For example, `wuf make` can be used to generate a test file for each
component found in `components.json` (which can be created with `wuf update`).

```md
Usage: wuf make [options]

combine data from `wuf update`, template and optional plugins to generate any kind of code.

Options:
  --input <string>      Path to `components.json` file created with `wuf
                        update`. Default is `.wuf/components.json`
  --output <string>     Path of root folder where generated files should be
                        created. Default is `./src`
  --template <string>   Path to EJS template to be used for generating code.
                        Can be path directly to a single ejs file, or path to a
                        folder containing templates.
  --plugin <string...>  Name of a built-in plugin or path to one. This flag can
                        be used multiple times to enable multiple plugins.
                        Plugins are executed in the same order they are
                        provided. By default, no plugins are used.
  -h, --help            display help for command
```

## Usage

`wuf make` is very versatile, it can be used for all sorts of purposes. To
understand how it works this document describes a few usage examples, from
simple to more advanced.

## Simplest usage

The simplest usage involves just a template. The following example would create `src/some-file.js` file. `wuf make` would use `.wuf/template.ejs` as the source for output

```sh
wuf make \
  --template .wuf/template.ejs \
  --output src/some-file.js
```

`.wuf/template.ejs`

```js
<% const javascript = "works" %>
This file is generated by wuf. Javascript <%= javascript %>!
```

Output would look like so:

`src/some-file.js`

```

This file is generated by wuf. Javascript works!
```

## Usage of a template

Template supports [EJS](https://ejs.co/), which allows to run javascript inside
template. It can range from simple things like printing values to more advanced
cases like iterating over arrays and modifying data.

However, any data modification should be done in a plugin (explained below).
Even though template supports arbitrary javascript, it is tedious to write
template and data modifications in one place, things get complicated fast with mixed syntax.

Templates are automatically populated with some global values:

- `components` - an array of component data found in `.wuf/components.json`.
  This array contains objects of the shape `{ name: "component-name", path: "component-path" }`. It is important to note, that this shape can be modified (or even removed) by plugins.

- `utils` - an object of utility functions, mainly to manipulate text:
  - `toCamel`: change `some-text` into `someText`
  - `toKebab`: change `someText` into `some-text`
  - `toSnake`: change `someText` into `some_text`
  - `toPascal`: change `someText` into `SomeText`

`demo-template.ejs`:

```ejs
This is a template file
There are <%= components.length %> components.
I like blue <%= utils.toPascal('da-ba-dee') %>.
```

Output would look like so (assuming there are 5 components in `.wuf/components.json`):

```txt
This is a template file
There 5 components.
I like blue DaBaDee.
```

## Usage of a plugin

This example uses a simple plugin for injecting data into the template.

```sh
wuf make \
  --template .wuf/template.ejs \
  --plugin .wuf/plugin.js \
  --output src/some-file.js
```

First `.wuf/template.ejs`:

```ejs
Hello <%= greeting %>!
```

`.wuf/template.ejs` prints `greeting` variable, but we didn't yet define its
value. That is done in

`.wuf/plugin.js`:

```js
module.exports = () => {
  return {
    greeting: "World",
  };
};
```

Whatever is returned by the plugin becomes globally available in the `template.ejs`.

### Exporting a plugin

Plugin should be a javascript file that has a default export. Exported value can either be function or an array of functions. When array of functions is exported, `wuf make` will execute those functions one after another, in the order they are provided.

`single-plugin.js`:

```js
module.exports = () => {
  // a single function
};
```

`multiple-plugins.js`:

```js
const plugin1 = () => {
  // first plugin
};
const plugin2 = () => {
  // second plugin
};

// exporting multiple plugins
module.exports = [plugin1, plugin2];
```

Plugins can also be async, both when returning a single plugin or an array of functions.

`async-plugin.js`:

```js
module.exports = async () => {
  await someAsyncAction();
  // a single function
};
```

It's worth mentioning that plugins can `require` any other javascript code. Plugins are run in `node`, so plugin can do anything that `node` can, for example:

`plugin-with-requires.js`:

```js
const path = require("path");
const fs = require("fs/promises");

module.exports = async (data, api) => {
  await fs.writeFile(path.join(api.cwd, "some-file"), "Hello world!", "utf8");

  // no return here, this plugin is only for side effects.
  // that's a valid use case!
};
```

### Plugin API

Plugin function receives two parameters:

- `data` - an object with values, initially filled by data from `--input`. If there are multiple plugins, data is passed and merged through each of them.
- `api` - an object with values and utility functions provided by `wuf`

```js
module.exports = (data, api) => {
  // ...
};
```

#### `data` parameter

First parameter is a dynamic object that can change between plugins. That's because plugins are meant for that - to modify or augment data, which is eventually passed into the template.

When `.wuf/components.json` is available, `data` is initially filled with `{ components }`, where `components` is an array of components from `components.json`.

For example, given `components.json`:

```json
{
  "Batman": {
    "path": "src/Batman"
  },
  "Robin": {
    "path": "src/Robin"
  }
}
```

`data` would be initially filled with:

```json
{
  "components": [
    { "name": "Batman", "path": "src/Batman" },
    { "name": "Robin", "path": "src/Robin" }
  ]
}
```

> object is transformed into array of objects so that it's more convenient for plugins to iterate over components.

When plugin `return`s an object, the next plugin will receive new `data` from previous plugin. Thus, it is possible to chain plugins and "pipe" data from one to the other.

#### `api` parameter

Second parameter contains a predefined set of values and fuctions. They are utilities to make it easier for plugin authors to modify `data` or do side effects, like `renderTemplate`.

Below is a typescript interface of `api`:

```ts
interface Api {
  cwd: string;
  output: string;
  renderTemplate({
    templatePath: string;
    output: string;
    data: Record<string, unknown>;
  }) => Promise<void>;
  cleanFolder(path);
  toCamel(str: string): string;
  toKebab(str: string): string;
  toSnake(str: string): string;
  toPascal(str: string): string;
}
```

## Advanced example

Knowing that `data` flows from one plugin to another, and about the utilities provided by `api`, we can easily iterate over `components` and create files for them.

We'll run `wuf make` with these flags:

```sh
wuf make \
  --plugin .wuf/plugin.js \
  --output src
```

> note that there is no --template in this case! That's okay, we'll use `renderTemplate` in the plugin

`.wuf/some-template.ejs`:

```ejs
Greetings, my name is <%= name %>
I am <%= data %>
```

`.wuf/plugin.js`:

```js
const createNames = () => {
  return {
    people: [
      { name: "Batman", data: "a detective" },
      { name: "Superman", data: "good looking" },
      { name: "Guitarman", data: "radio active" },
    ],
  };
};

const saveFiles = async (data, api) => {
  data.people.forEach(async (person) => {
    await renderTemplate({
      templatePath: path.join(api.cwd, ".wuf", "some-template.ejs"),
      output: path.join(api.output, `${person.name}.txt`),
      data: person,
    });
  });
};

module.exports = [createNames, saveFiles];
```

Once `wuf make` does it's job, we should get three new files under `src` folder:

`src/Batman.txt`:

```
Greetings, my name is Batman
I am detective
```

`src/Superman.txt`:

```
Greetings, my name is Superman
I am good looking
```

`src/Guitarman.txt`:

```
Greetings, my name is Guitarman
I am radio active
```

---

This technique can be applied to create many kinds of files, for example:

- generated tests
- generated tests only for a subset of components
- generated documentation files
- generated... Insert your idea here
